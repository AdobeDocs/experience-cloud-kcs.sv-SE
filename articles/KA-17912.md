---
title: Cachelagring
description: Beskrivning
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: 2/7/2022 5:13:07 PM
article-published-by: Roxann McGlumphy
article-published-date: 2/7/2022 5:13:28 PM
version-number: 3
article-number: KA-17912
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ee0f4935-3988-ec11-93b0-0022480837ff
exl-id: a5da3fc9-c0a0-4d5a-8369-a96dad9e2b49
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1517'
ht-degree: 0%

---

# Cachelagring

## Beskrivning

Det här dokumentet förklarar hur dispatcher-cachning sker och hur den kan konfigureras<br><br> <br><br>[Innehållsförteckning](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html)

## Upplösning


<b>Cachelagra kataloger</b>

Vi använder följande standardcachekataloger i våra baslinjeinstallationer

- Författare

   - /mnt/var/www/author
- Utgivare

   - /mnt/var/www/html


När varje begäran går igenom dispatchern följer förfrågningarna de konfigurerade reglerna för att behålla en lokalt cachelagrad version som svar på giltiga objekt

<b>Obs!</b>

Vi har avsiktligt sparat publicerad arbetsbelastning separat från författarens arbetsbelastning, eftersom när Apache söker efter en fil i DocumentRoot så vet det inte vilken AEM den kommer från. Så även om du har inaktiverat cache i författargruppen, och om författarens DocumentRoot är samma som utgivaren, kommer den att leverera filer från cachen när den finns. Det innebär att du kan leverera författarfiler från publicerade cacheminnen och skapa en riktigt fantastisk mixningsupplevelse för besökarna. Att ha separata DocumentRoot-kataloger för olika publicerat innehåll är också en dålig idé. Du måste skapa flera omcachelagrade objekt som inte skiljer sig åt mellan platser som clientlibs, och du måste också konfigurera en agent för att tömma replikeringen för varje DocumentRoot som du konfigurerar. Öka mängden spolning över huvudet när varje sida aktiveras. Använd namnutrymmet för filer och deras fullständiga cachelagrade sökvägar för att undvika flera DocumentRoot-filer för publicerade webbplatser.



<b>Konfigurationsfiler</b>

Dispatcher styr vad som kvalificerar sig som cacheable i /cache {-avsnittet i en servergruppsfil. 
I AMS baslinjekonfigurationsgrupper hittar du våra inkluderingar enligt nedan:


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


När du skapar regler för vad som ska cachelagras eller inte, se dokumentationen [här](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>Cacheförfattare</b>

Det finns många implementeringar vi har sett där folk inte cachelagrar författarinnehåll. 
De saknar en stor uppgradering vad gäller prestanda och lyhördhet för författarna.

Låt oss prata om strategin som har tagits för att konfigurera vår författargrupp så att den cachelagras ordentligt.

Här är en basförfattare/cache {-avsnitt i vår författargruppsfil:


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


Det viktiga att notera här är att <b>/docroot</b> är inställt på cachekatalogen för författaren.

<b>Obs!</b>

Kontrollera att DocumentRoot i författarens .vhost-fil matchar parametern farm/docroot

Cachereglerna innehåller en -programsats som innehåller filen <b>/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any</b> som innehåller dessa regler:


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


I ett författarscenario ändras innehållet hela tiden och i rätt syfte. Du vill bara cachelagra objekt som inte ändras så ofta.
Vi har regler för att cachelagra /libs eftersom de är en del av AEM och kommer att ändras tills du har installerat Service Pack, Cumulative Fix Pack, Upgrade eller Hotfix. Att cachelagra dessa element är därför en smula vettigt och har stora fördelar med författarupplevelsen för slutanvändare som använder webbplatsen.

<b>Obs!</b>

Kom ihåg att dessa regler även cachelagrar <b>/apps</b> det är här som anpassad programkod finns. Om du utvecklar din kod för den här instansen blir den väldigt förvirrande när du sparar filen och du ser inte om den återspeglar den i användargränssnittet eftersom den sparar en cachelagrad kopia. Avsikten här är att om du distribuerar koden till AEM blir det också ovanligt och en del av driftsättningsstegen bör vara att rensa författarcachen. Även här är fördelen stor, vilket gör att den tillgängliga koden kan köras snabbare för slutanvändarna.



<b>ServeOnStale (AKA-server vid föråldrad/SOS)</b>

Det här är en av de här pärlorna i en av avsändarens egenskaper. Om utgivaren är under belastning eller inte svarar kommer den oftast att generera en http-svarskod på 502 eller 503. Om det händer och den här funktionen är aktiverad instrueras avsändaren att fortsätta att leverera det innehåll som finns kvar i cachen som en bra åtgärd, även om det inte är en ny kopia. Det är bättre att skicka något om du har det, i stället för att bara visa ett felmeddelande som inte har någon funktionalitet.

<b>Obs!</b>

Tänk på att om utgivarrenderaren har en sockettimeout eller ett felmeddelande om 500 kommer den här funktionen inte att aktiveras. Om AEM bara inte kan nås händer ingenting

Den här inställningen kan ställas in i vilken grupp som helst, men det är bara bra att använda den i publiceringsservergruppens filer. Här följer ett syntaxexempel på funktionen som är aktiverad i en servergruppsfil:


```
/cache { 
    /serveStaleOnError "1"
```




<b>Cachelagra sidor med frågeparametrar/argument</b>

<b>Obs!</b>

Ett av de normala beteendena i modulen Dispatcher är att om en begäran har en frågeparameter i URI:n (visas vanligtvis som /content/page.html<b>?myquery=value</b>) går den inte att cachelagra filen och direkt till AEM. Den här begäran behandlas som en dynamisk sida och bör inte cachas. Detta kan få cacheminnets effektivitet att påverkas.

Om du har sidor i AEM som tar emot GET argument eller frågeparametrar på adressraden som hjälper sidan att fungera, men som inte återger olika HTML-koder, kan du ange för avsändaren vilka argument som ska ignoreras och fortfarande cachelagra sidan.
Som exempel har någon skapat en mekanism för djuplänksreferens i sociala medier som använder argumentreferensen i URI:n för att ta reda på var personen kom ifrån.

<b>Exempelanvändning:</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

Sidan är 100 % tillgänglig men cachelagras inte eftersom argumenten finns. 
För att lösa problemet lägger vi till följande avsnitt i vår servergruppskonfigurationsfil:


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


När avsändaren ser begäran kommer avsändaren att ignorera det faktum att begäran har frågeparametern ?reference och fortfarande cachelagra sidan



<b>Cachelagra svarshuvuden</b>

Det är ganska uppenbart att avsändaren cachelagrar HTML-sidor och klienten, men visste du att den även kan cachelagra särskilda svarshuvuden längs med innehållet i en fil med samma namn som filtillägget .h. På så sätt kan nästa svar inte bara på innehållet utan även på de svarshuvuden som ska följa med det från cachen.

AEM kan hantera mer än bara UTF-8-kodning

Ibland har objekt särskilda rubriker som hjälper till att styra cachefilens kodningsinformation och de senaste ändrade tidsstämplarna.

Dessa värden rensas som standard när de cachelagras och httpd-webbservern i apache gör sin egen bearbetning av resursen med sina vanliga filhanteringsmetoder, som vanligtvis är begränsad till mime-typgissning baserat på filtillägg.

Om du har dispatchern cachelagrar resursen och de rubriker du vill ha kan du visa rätt upplevelse och se till att all information gör den till klientens webbläsare.

Här är ett exempel på en servergrupp med de rubriker som ska cachelagras angivna:


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


I det här exemplet har de konfigurerat AEM för att hantera rubriker som CDN söker efter för att veta när det ska ogiltigförklaras dess cache. Betydelsen är nu att AEM kan avgöra vilka filer som blir ogiltiga baserat på rubriker.

<b>Obs!</b>

Kom ihåg att du inte kan använda reguljära uttryck eller matchning av glob. Det är en litteral lista över de rubriker som ska cachelagras. Placera bara i en lista över de literalrubriker som du vill att de ska cachelagras.



<b>Förvräng giltighetsperiod automatiskt</b>

På AEM system som har mycket aktivitet från författare som gör många sidaktiveringar kan du ha ett tävlingsvillkor där upprepade ogiltigförklaringar förekommer. Omfattande upprepad rensningsbegäran är inte nödvändig och du kan skapa en viss tolerans för att inte upprepa en tömning förrän respitperioden har rensats.

<b>Exempel på hur detta fungerar:</b>

Om du har 5 begäranden om ogiltigförklaring /content/example/en/ inträffar alla inom en 3-sekundersperiod.

Om den här funktionen är inaktiverad blir cachekatalogen /content/exampleeco/en/ 5 gånger ogiltig

Om den här funktionen är aktiverad och inställd på 5 sekunder blir cachekatalogen /content/exampleeco/en/ ogiltig<b>en</b>

Här följer ett exempel på syntaxen för den här funktionen som konfigureras för en respitperiod på 5 sekunder:


```
/cache { 
    /gracePeriod "5"
```




<b>TTL-baserad invalidering</b>

En nyare funktion i dispatchermodulen var <b>TTL (Time To Live)</b> baserade invalideringsalternativ för cachelagrade objekt. När ett objekt cachelagras söker det efter cachekontrollhuvuden och skapar en fil i cachekatalogen med samma namn och en <b>.ttl</b> tillägg.

Här är ett exempel på funktionen som konfigureras i servergruppens konfigurationsfil:


```
/cache { 
    /enableTTL "1"
```


<b>Obs!</b>

Kom ihåg att AEM fortfarande måste konfigureras för att skicka TTL-rubriker för dispatcher för att de ska respekteras. Om du växlar den här funktionen kan avsändaren bara veta när de filer som AEM har skickade cachekontrollrubriker ska tas bort. Om AEM inte börjar skicka TTL-rubriker gör inte dispatchern något särskilt här.



<b>Regler för cachefilter</b>

Här är ett exempel på en baslinjekonfiguration för vilken element ska cachelagras på en utgivare:


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


Vi vill göra vår publicerade webbplats så girig som möjligt och cachelagra allt.

Om det finns element som bryter upplevelsen vid cachelagring kan du lägga till regler som tar bort alternativet att cachelagra det objektet. Som du ser i exemplet ovan bör csrf-tokens aldrig cachelagras och har uteslutits. Mer information om hur du skriver dessa regler finns [här](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)
