---
title: "Inkrementell fråga hämtar alla poster i stället för bara nya"
description: Beskrivning
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# Inkrementell fråga hämtar alla poster i stället för bara nya

## Beskrivning

<b>Miljö</b>
Campaign Classic


<b>Problem/symtom</b>
Inkrementella frågor fungerar inte som förväntat. I stället för att bara hämta nya poster sedan den senaste körningen, plockas alla poster upp varje gång som en vanlig frågeaktivitet.


## Upplösning


Problemet har åtgärdats i Adobe Campaign Classic 20.1.1 (version 9122 och senare).

<b>Tillfälliga lösningar som kunderna kan använda:</b>

<b>Tillfällig lösning 1</b>: Stoppa rensningsarbetsflödet och kör det då och då för att rensa upp databasen och hårddisken tills korrigeringen är klar och tillgänglig. Vi rekommenderar inte om du inte har en planerad uppgradering.

<b>Tillfällig lösning 2</b>: Anta att den inkrementella frågeaktiviteten påverkas. Undvik problemet genom att göra samma sak som den inkrementella frågan gör genom att skapa ett beständigt schema för innehållet i historiktabellen. Använd en kombination av fråga och uppdatera dataaktiviteter för att efterlikna beteendet. Detta måste göras för alla arbetsflöden som kräver den inkrementella frågan.

<b>Tillfällig lösning 3</b>: Anta att den inkrementella frågeaktiviteten påverkas. Undvik problemet genom att lägga till ett granskningsfält `tsCreated/tsLastModified` till det aktuella schemat. Den stegvisa frågan konverteras sedan till en normal frågeaktivitet med en where-sats som &quot;tscreated GetDate()&quot;.

<b>Tillfällig lösning 4</b>:

1. Skapa en ny sekvens `xtknewworkflowid` och initiera den till något långt från de aktuella arbetsflödes-ID-intervallen.
2. Ändra `xtkworkflow` schema som ska användas `pkSequence`.
3. Be kunden klona alla berörda arbetsflöden och ta bort de ursprungliga.
4. När kunden är redo att uppgradera tar du bort den här korrigeringen genom att gå tillbaka till `xtknewId` för att skapa arbetsflöden (för att undvika oönskade överraskningar).

<b>Orsak</b>
Skulden är rensningsarbetsflödet.

Det inkrementella frågearbetsflödet fungerar så här:

1. Underhåller en historiktabell med resultat från tidigare iterationer.
2. Hämtar alla rader från målfrågan.
3. Filtrerar ut alla rader i historiktabellen
4. Lägger till återstående resultat i historiktabellen för nästa iterationsfiltrering.


Det här namnet på historikarbetsytan har följande betydelse:
`wkfhistoworkflowid` `activityName_`

För arbetsflödes-ID 0 (för kunder där `xtknewid` tillåter negativa sekvenser) ser vi att det faktiskt är:

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.`

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
