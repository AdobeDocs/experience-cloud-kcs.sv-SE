---
title: "SegmentNotFoundException och IllegalArgumentException"
description: Beskrivning
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/offline-compaction-fails-with-SegmentNotFoundException-and-IllegalArgumentException.html"
bug: false
article-created-by: Emily Geary
article-created-date: "4/12/2021 6:09:12 PM"
article-published-by: Emily Geary
article-published-date: "4/12/2021 6:09:50 PM"
version-number: 7
article-number: KA-16457
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=7ed24a2d-ba9b-eb11-b1ac-000d3a3680d8"
exl-id: 54f6bac4-f81b-4685-89e6-eaedf60f3552
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '956'
ht-degree: 0%

---

# SegmentNotFoundException och IllegalArgumentException

## Beskrivning


Det går inte att köra en offlinekomprimering med SegmentNotFoundException när det finns integritetsproblem i databasen.

Du observerar SegmentNotFoundException i AEM loggfiler och AEM fungerar inte som förväntat

ELLER

Det går inte att köra en offlinekomprimering med SegmentNotFoundException när det finns integritetsproblem i databasen. En stackspårning som liknar den nedan finns i loggarna:

`13:51:21.523 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 4d139bc4-150c-4f0a-b82a-40a4e519fe8a. Creation ` `date` `delta is 4 ms.`

`org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855) oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)  oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) oak-run-1.0.22.jar:1.0.22`

`...`

`Exception ` `in` `thread ` `"main"` `org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101)`

`...`

ELLER

Det går inte att köra en offlinekomprimering med IllegalArgument Exception när det finns integritetsproblem i databasen. En stackspårning som liknar den nedan finns i loggarna:


| `java.lang.IllegalArgumentException`<br><br>`at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.(ListRecord.java:41)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntry(ListRecord.java:64)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:81)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentStream.` `read` `(SegmentStream.java:153)`<br><br>`at org.apache.jackrabbit.oak.commons.IOUtils.readFully(IOUtils.java:53)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.getBlobKey(Compactor.java:412)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:362)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:321)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.access$500(Compactor.java:54)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.propertyAdded(Compactor.java:227)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.propertyAdded(CancelableDiff.java:47)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:156)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)` |
| --- |


<b>Orsak</b>

Ett SegmentNotFoundException returneras när ett segment inte finns när komprimeringen försöker läsa noden. Det kan finnas olika rotorsaker till detta:

1. Segmentet har tagits bort genom manuell åtgärd (t.ex. rm -rf /).
2. Segmentet har tagits bort av skräpinsamlingen för revision.
3. Det går inte att hitta segmentet på grund av ett fel i koden.


Om problemet orsakas av skräpinsamling för revision (punkt 2), kontrollerar du att onlinekomprimering är inaktiverat för att undvika att fler noder skadas.


## Upplösning


Det finns flera procedurer som vi kan följa för att lösa situationen och slutföra offlinekompaktionen.

*Viktigt:* Utför en fullständig säkerhetskopiering av databasen innan du följer stegen nedan.



<b>S. Återgå till den senast fungerande versionen av segmentbutiken.</b>

Kontrollkörningsläget för ekakning kan användas för att avgöra den senaste fungerande versionen av en segmentbutik. Den kan användas för att manuellt återställa en skadad segmentbutik till den senaste bra versionen.

*Varning:<b>* </b>Den här processen återställer data i systemet till en tidigare tidpunkt.  Om du inte vill förlora ändringar i systemet kan du prova alternativ B nedan i stället.

Så här utför du kontroll och återställning:

1. Ladda ned en fil som kan köras på eken härifrån [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/)
2. Sluta AEM.
3. Kör det här kommandot:

   `java -jar oak-run-*.jar check --bin=-1 crx-quickstart/repository/segmentstore/`



   Det här kommandot söker bakåt i ändringarna tills det hittar ett konsekvent:

   `14:00:30.783 main INFO  o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880`



   (Om ConsistencyChecker misslyckas, gå till nästa avsnitt)


4. Återställ databasen till den här versionen genom att redigera.

   `/crx-quickstart/repository/segmentstore/journal.log.`



   Ta bort alla rader efter raden som innehåller den senaste fungerande ändringen. Om du vill ta reda på vilket datum och vilken tid du återställer databasen till kör du det här kommandot i segmentlagermappen (ersätt afdb922d-ba53-4a1b-aa1b-1cb044b535cf med den senaste bra versionen i din journal.log):

   `find . -type f -name "data*.tar" -exec sh -c "tar -tvf {} |grep afdb922d-ba53-4a1b-aa1b-1cb044b535cf" \; -print`



   Utdata skulle visa ungefärligt datum och ungefärlig tid för den ändringen.


5. Ta bort alla `./crx-quickstart/repository/segmentstore/*.bak files.`
6. Om du använder AEM6.0 laddar du ned den version som är installerad i AEM för de återstående stegen.  Ladda ned den här [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/).
7. Kör rensning av kontrollpunkter för att ta bort överblivna kontrollpunkter:

   `java -jar oak-run-*.jar checkpoints ./crx-quickstart/repository/segmentstore rm-unreferenced.`


8. Komprimera slutligen databasen:

   `java -jar oak-run-*.jar compact ./crx-quickstart/repository/segmentstore/`




<b>B. Ta bort skadade noder manuellt.</b>

I AEM inställningar för tarMK utan konfigurerad FileDatastore och situationer där skador förekommer i binärfilerna kan du göra följande.

*Varning:*Nedanstående procedur är avsedd för avancerade användare.  När du tar bort skadade noder måste du se till att de inte är systemnoder (till exempel /home, /jcr:system).  Eller om de är systemnoder måste du se till att du kan återställa dem.  Kontakta AEM kundtjänst om du är osäker.

1. Sluta AEM.
2. Använd Oak-körningskonsolen och läs in växlingsskriptet childCount för att identifiera skadade noder i segmentarkivet:

   Läs in konsolens ekar-gränssnitt:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   Kör de två kommandona nedan i gränssnittet för att läsa in skriptet och köra det:

   `:load`

   `https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy`

   `countNodes(session.workingNode)`



   Detta resulterar i följande utdata som anger sökvägen till de skadade noderna:

   `21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms.`

   `warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content`



   I vissa fall är problemet länkat till binära egenskaper och gruppskriptet childCount kan inte hitta några skadade noder.  I dessa fall kan du använda följande kommando som läser de första 1024 byten för varje binär fil som påträffas under genomgången (observera att det här kommandot blir långsammare och bör bara användas när ovanstående inte returnerar det förväntade resultatet):

   `countNodes(session.workingNode,true)`


3. Ta bort alla identifierade skadade noder i utdata från det senaste kommandot med rmNodes.groovy

   Läs in konsolens ekar-gränssnitt:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   Läs in grupperingsskriptet:

   `:load`

   `https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy`



   Kör kommandot rmNode för att ta bort den skadade noden, ersätt /path/to/corrupt/node med sökvägen till den skadade nod som du måste ta bort.

   `rmNode(session, "/path/to/corrupt/node")`



   Där den skadade nodsökvägen är sökvägen som fås i steg 2, till exempel: `"/content/dam/test.txt/jcr:content/renditions/original/jcr:content/"`
Obs! När du använder oak-run.jar version 1.6.13 och senare, anger du JVM-parametern —read-write om du får ett fel som:






   ```
   / rmNode(session,"/path/to/corrupt/node")    Removing node /path/to/corrupt/node    ERROR java.lang.UnsupportedOperationException:    Cannot write to read-only store    at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171)    at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318)    at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333)    at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source)    at groovysh_evaluate.rmNode (groovysh_evaluate:11)
   ```

4. Upprepa steg 3 för alla noder som finns i steg 2.

   Det här ovanstående rmNode-kommandot ska returnera true för den skadade sökvägen, vilket betyder att den har tagits bort. Se till att de hittade tre skadade sökvägarna tas bort genom att köra kommandot rmNode på de sökvägarna igen. Nästa körning ska returnera false.

   Om du fortfarande ser att samma sökvägar finns i databasen använder du den patchade versionen av ekrun jar, d.v.s. oak-run-1.2.18-NPR-17596

   Vad kör den patchade versionen av Oak Jar Do?

   Den här versionen av jar hoppar över oläsbara binärfiler vid komprimering som ersätter dem med binära nollbyte och loggar undantaget och sökvägen till systemservern. Den komprimerade databasen bör sedan skicka en körkontroll, nodräkningsskriptet och du bör även kunna komprimera den igen med en icke-patchad ekkörning.


5. Utför en rensning av kontrollpunkter genom att lista kontrollpunkter med hjälp av nedan. Om det finns fler än en kontrollpunkt ska du rensa upp dem:

   `nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &`
6. Kör en offlinekomprimering.  Om du inte vet hur du kör offlinekomprimering kan du se [här](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).
7. Starta servern och vänta på att indexeringen ska slutföras.
