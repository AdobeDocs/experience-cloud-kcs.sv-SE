---
title: Felsöka SegmentNotFoundException när Problem rapporteras i AEM 6.x
description: Beskrivning
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# Felsöka SegmentNotFoundException när Problem rapporteras i AEM 6.x

## Beskrivning


<b>Felsöka SegmentNotFoundException när Problem rapporteras i AEM 6.x</b>

A <b>SegmentNotFoundException</b> i felloggen betyder att ett segment inte finns längre, även om någon försöker att fortfarande komma åt det. Det finns i stort sett tre olika grundorsaker till detta: segmentet har tagits bort genom manuell åtgärd (t.ex. rm -rf /), segmentet har tagits bort genom skräpinsamling eller så kan segmentet inte hittas på grund av ett fel i koden.

Det kan finnas undantag som följande i loggar:

...

org.apache.jackrabbit.oak.segment.SegmentNotFoundException: Segment d2c720c4-c146-4ab1-ac37-542aad93c33f hittades inte i org.apache.jackrabbit.oak.segment.FileStore$8.call(FileStore.java:602) på org.apache.jackit .oak.segment.file.FileStore$8.call(FileStore.java:542) at org.apache.jackrabbit.oak.segmentCache.getSegment(SegmentCache.java:95) at org.apache.jackrabbit.oak.segment.fileStore.readSegment(FileStore.java:542) at org.apache.jackrabbit.oak.segment.SegmentId.getSegment(SegmentId.java:125) at org.apache.jackrabbit.oak.segment.Record.getSegment(Record.java:70) at org.apache.jackrabbit.oak.segment.MapRecord.Record compare(MapRecord.java:424) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391) at org.apache.jackit.oak.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148) at org.apache.jackrabbit.oak .segment.MapRecord$3.childNodeChanged(MapRecord.java:442) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490) at org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:java 433) at org.apache.jackrabbit.oak.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:608) at org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52) at org.ap. ache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdate.java:695) på org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.runWhenPerowed(AsyncIndexUpdate.java:543) på org.apache.rabbit .oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402) på org.apache.sling.Commons.schemer.impl.QuartzJobExecutor.execute(QuartzJobExecutor.java:118) på org.quartz.core.JobRunShell.hell run(JobRunShell.java:202) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor .java:617) at java.lang.Thread.run(Thread.java:745)

...


## Upplösning


Det finns två metoder som vi kan följa för att åtgärda problemet och ta bort inkonsekvenser i databasen som beskrivs nedan i avsnitten A och B.

<b>S. Återgå till den senast fungerande versionen av segmentbutiken.</b>

För det första måste vi använda ekkörningsverktyget som är en körbar jar1 som innehåller allt du behöver för en enkel ekinstallation och ekrelaterade åtgärder.

Kontrollkörningsläget för ekakning kan användas för att avgöra den senaste fungerande versionen av en segmentbutik.  Den kan användas för att manuellt återställa en skadad segmentbutik till den senaste bra versionen.

*Varning: Den här processen återställer data i systemet till en tidigare tidpunkt.  Om du inte vill förlora ändringar i systemet kan du prova alternativ B nedan i stället.*

Så här utför du kontroll och återställning:

1. Ladda ned en version av eko-run som matchar din eke-kärnversion från [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. Om du vill återställa ett skadat segmentlager till den senaste fungerande tillståndsändringen till CQ:s arbetskatalog (den som innehåller snabbstartmappen) och säkerhetskopiera alla filer i ./crx-quickstart/database/segmentstore/.
3. Kör konsekvenskontrollen, java -Xmx6000m -jar oak-run-\*.jar check —bin=-1 /path/to/crx-quickstart/database/segmentstore Detta söker bakåt i versionerna tills det hittar en konsekvent version: Leta efter meddelanden som nedan: main INFO o.a.j.o.p.s.f.t.ConsistencyChecker - Hittade den senaste goda versionen afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. Återställ databasen till den här versionen genom att redigera./crx-quickstart/repository/segmentstore/journal.log och ta bort alla rader efter raden som innehåller den senaste bra ändringen.
5. Ta bort alla ./crx-quickstart/database/segmentstore/\*.bak-filer.
6. Kör rensning av kontrollpunkter för att ta bort överblivna kontrollpunkter med följande kommando: java -Xmx6000m -jar oak-run-\*.jar checkpoints /path/to/crx-quickstart/database/segmentstore rm-unreferenced
7. Komprimera slutligen databasen: java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/databas/segmentstore/




*Det kan finnas fall när ekskörningskontrollen inte kan hitta den korrekta versionen och vi får &quot;ConsistencyChecker - No good revision found&quot; när vi kör kommandot check.*
<b>Så här åtgärdar du fel när ConsistencyChecker påträffas - ingen bra revision hittades vid konsekvenskontroll</b>


<b>B. Ta bort skadade noder manuellt.</b>

I AEM inställningar för tarMK utan konfigurerad FileDatastore och situationer där skador förekommer i binärfilerna kan du göra följande.

\*Varningn:\*Proceduren nedan är avsedd för avancerade användare.  När du tar bort skadade noder måste du se till att de inte är systemnoder (till exempel /home, /jcr:system).  Eller om de är systemnoder måste du se till att du kan återställa dem.  Kontakta AEM kundtjänst om du är osäker.



1. Sluta AEM.
2. Använd Oak-körningskonsolen och läs in växlingsskriptet childCount för att identifiera skadade noder i segmentarkivet:


Läs in konsolens ekar-gränssnitt:

java -jar oak-run-\*.jar console crx-quickstart/databas/segmentstore

Kör de två kommandona nedan i gränssnittet för att läsa in skriptet och köra det:

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

Detta resulterar i följande utdata som anger sökvägen till de skadade noderna:

21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - segmentet hittades inte: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Skapandedatum för delta är 3 ms.

varning det gick inte att läsa noden /content/dam/test.txt/jcr:content/renditions/original/jcr:content

I vissa fall är problemet länkat till binära egenskaper och gruppskriptet childCount kan inte hitta några skadade noder.  I dessa fall kan du använda följande kommando som läser de första 1024 byten för varje binär fil som påträffas under genomgången (observera att det här kommandot blir långsammare och bör bara användas när ovanstående inte returnerar det förväntade resultatet):

countNodes(session.workingNode,true)

3. Ta bort alla identifierade skadade noder i utdata från det senaste kommandot med rmNodes.groovy

Läs in konsolskal som körs med kommandot nedan:

java -jar oak-run-\*.jar console crx-quickstart/databas/segmentstore

Läs in grupperingsskriptet:

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

Kör kommandot rmNode för att ta bort den skadade noden, ersätt /path/to/corrupt/node med sökvägen till den skadade nod som du måste ta bort.

rmNode(session, &quot;/path/to/corrupt/node&quot;)

Där den skadade nodsökvägen är sökvägen som fås i steg 2, till exempel: &quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot; Obs! När du använder oak-run.jar version 1.6.13 och senare, anger du JVM-parametern —read-write om du får ett fel som:

/ rmNode(session,&quot;/path/to/corrup/node&quot;) Tar bort noden /path/to/corrup/node ERROR java.lang.UnsupportedOperationException:    Det går inte att skriva till det skrivskyddade arkivet på org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171) at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318) at.org apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:11) at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581) at org.apache.se jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333) at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source) at groovysh_evaluate.rmNode (groovysh_evaluate:11)

4. Upprepa steg 3 för alla noder som finns i steg 2.

Det här ovanstående rmNode-kommandot ska returnera true för den skadade sökvägen, vilket betyder att den har tagits bort. Se till att de hittade tre skadade sökvägarna tas bort genom att köra kommandot rmNode på de sökvägarna igen. Nästa körning ska returnera false.

Om du fortfarande ser att samma sökvägar finns i databasen kan du använda den patchade versionen av ekkörningsbehållaren, dvs. oak-run-1.2.18-NPR-17596

Vad kör den patchade versionen av Oak Jar Do?

Den här versionen av jar hoppar över oläsbara binärfiler vid komprimering som ersätter dem med binära nollbyte och loggar undantaget och sökvägen till systemservern. Den komprimerade databasen bör sedan skicka en körkontroll, nodräkningsskriptet och du bör även kunna komprimera den igen med en icke-patchad ekkörning.

5. Utför en rensning av kontrollpunkter genom att lista kontrollpunkter med hjälp av nedan. Om det finns fler än en kontrollpunkt ska du rensa upp dem:

nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/databas/segmentstore rm-allnohup.out &amp;

6. Kör en offlinekomprimering.  Om du inte vet hur du kör offlinekomprimering kan du se [här](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. Starta servern och vänta på att indexeringen ska slutföras.
